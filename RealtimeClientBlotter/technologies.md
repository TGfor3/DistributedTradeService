## Technologies


**Docker for Container Management:** Docker will be used to manage the deployment and operation of our applications, ensuring that each component runs in a consistent environment. This approach simplifies the deployment process, improves scalability, and allows for easier maintenance and updates. Docker was chosen for its widespread adoption and the ease with which it allows us to manage microservices.

**HAProxy for Client Routing:** Chosen for its reliability, flexibility, and powerful load balancing capabilities, HAProxy is the cornerstone of our traffic management system. HAProxy distributes incoming requests across our servers using a round-robin algorithm, ensuring an even load and preventing any single server from becoming a bottleneck. The "check" feature in HAProxy monitors the health of our servers in real-time, allowing for automatic failover and enhanced uptime. Additionally, HAProxy routes traffic based on URL paths, providing precise control over request handling and optimizing resource utilization. HAProxy was selected over other load balancers for its proven performance in high-traffic environments and its extensive feature set tailored to our needs.

**Hazelcast for Coordination:** Chosen for its in-memory data grid capabilities, scalability, and efficiency, Hazelcast is integral to our system architecture. Hazelcast enables us to colocate clients on the same servers, reducing latency and enhancing performance through data locality. Additionally, Hazelcast maintains real-time updates about server liveness, ensuring high availability and rapid failover in case of server issues. By using Hazelcast, we achieve seamless scalability and robust fault tolerance, essential for maintaining a responsive and resilient system. Hazelcast was selected for its superior in-memory processing and its ability to handle dynamic data distribution and server health monitoring effectively.

**Kafka for Event Streaming:** Chosen for its high throughput, scalability, and fault tolerance, Kafka handles the intake of real-time market value updates. Kafka was selected over other messaging systems for its seamless scaling and robust performance in handling large volumes of data with low latency, benefiting from its efficient data streaming and lack of message acknowledgment overhead.

**Java for Client Data Routing Service:** Java is our coding language for the logic of handling the routing of incoming Kafka messages to the appropriate clients. Java's strong performance, reliability, and robust ecosystem make it well-suited for building complex, high-performance applications.

**JavaScript for SSEs and Gateway:** JavaScript is our coding language for routing clients to their colocated servers and streaming market value updates through those servers. JavaScript's ability to handle asynchronous operations and real-time updates makes it ideal for this task. Its ease of integration with front-end technologies ensures a seamless development process, enabling efficient and dynamic client-server interactions. The language's extensive ecosystem, including libraries, supports the implementation of complex, high-performance functionalities necessary for our system.

By leveraging these technologies, we aim to build a robust, scalable, and efficient system that meets our requirements for efficiently streaming updates to the user's dashboard.
